## 단방향 연관관계

```
💡예제 시나리오

- 회원과 팀이 있다.
- 회원은 하나의 팀에만 소속될 수 있다.
- 회원과 팀은 다대일 관계다.
```

✒️ 들어가기 앞서 객체를 테이블에 맞춰 모델링 했을 때의 문제점을 알아보자!

### 객체를 테이블에 맞추어 모델링

🔑 연관관계가 없는 객체

<img src="https://github.com/iieunji023/jpa-with-spring-boot-basic/blob/main/images/단방향1.png" width="350">

🔑 참조 대신에 외래 키 그대로 사용
> 엔티티 생성

<details>
      <summary>Member.java</summary>

    @Entity

    public class Member {

    @Id @GeneratedValue
    @Column(name="MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String name;

    @Column(name="TEAM_ID")
    private Long  teamId;

    }

</details>

<details>
      <summary>Team.java</summary>

    @Entity
    public class Team {
    @Id
    @GeneratedValue
    @Column(name="TEAM_ID")
    private Long id;
    private String name;
    }

</details>

> 테이블 생성

```
Hibernate: 
    create table Member (
        MEMBER_ID bigint not null,
        TEAM_ID bigint,
        USERNAME varchar(255),
        primary key (MEMBER_ID)
)
Hibernate: 
    create table Team (
        TEAM_ID bigint not null,
        name varchar(255),
        primary key (TEAM_ID)
)
```

🔑  **외래 키 식별자를 직접 다룸**

> 팀과 회원 저장
```
Team team = new Team();

team.setName("TeamA");
em.persist(team);

Member member = new Member();
member.setUsername("member1");
member.setTeamId(team.getId());
em.persist(member);

tx.commit();
```

- `member.setTeamId(team.getId());`
    - 객체지향스럽지 않음 -_-..
    - `member.setTeam(~~);` 으로 해야 할 거 같은데..!

> h2 콘솔 확인

<img src="https://github.com/iieunji023/jpa-with-spring-boot-basic/blob/main/images/단방향2.png" width="200">

🔑 식별자로 다시 조회, 객체 지향적인 방법은 아니다.
```
Member findMember = em.find(Member.class, member.getId());
Long findTeamId = findMember.getTeamId();
Team findTeam = em.find(Team.class, findTeamId);
```
- find()를 통해 계속 값을 찾아야 함😂

💡 결론: 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력관계를 만들 수 없다.

- **테이블은 외래 키로 조인**을 사용해서 연관된 테이블을 찾는다.
- **객체는 참조**를 사용해서 연관된 객체를 찾는다.
- 테이블과 객체 사이에는 이런 큰 간격이 있다.

문제점을 알아봤으니 이런 문제를 해소할 수 있는 방법들을 알아보자

## 단방향 연관관계

### 객체 지향 모델링
🔑 객체 연관관계 사용
<img src="https://github.com/iieunji023/jpa-with-spring-boot-basic/blob/main/images/단방향3.png" width="350">

- TeamId가 아닌 Team 객체를 참조

🔑 **객체의 참조와 테이블의 외래 키를 매핑**

> 엔티티 수정

<details>
      <summary>Member.java</summary>

- 수정 전
```
@Column(name="TEAM_ID")
private Long  teamId;
```
- Team객체가 아닌 아이디로 맵핑
- 객체 지향과 맞지 않음
  
- 수정 후
```
@ManyToOne
@JoinColumn(name="TEAM_ID") 
private Team team;
```
- `@ManyToOne`
  - Member와 Team 객체의 관계를 JPA에게 알려주기
  - 1개의 팀에 여러 멤버가 있으니까 팀이 1, 멤버가 N
- `@JoinColumn(name="TEAM_ID")`
  - 테이블 연관관계의 FK와 연결시켜주기

</details>

🔑 **연관관계 저장 및 참조호 연관관계 조회**

> 테이블에 값 등록, 조회

<details>
      <summary>JpaMain.java</summary>

```
// 저장
Team team = new Team();
team.setName("TeamA");
em.persist(team);

Member member = new Member();
member.setUsername("member1");
member.setTeam(team);
em.persist(member);

// 조회
Member findMember = em.find(Member.class, member.getId());
Team findTeam = findMember.getTeam();
System.out.println("findTeam.getName() = " + findTeam.getName());

tx.commit();
```

- 출력 결과
  ```
  findTeam.getName() = TeamA
  Hibernate:
    /* insert for
    hellojpa.Team */insert
    into
    Team (name, TEAM_ID)
    values
    (?, ?)
  Hibernate:
    /* insert for
    hellojpa.Member */insert
    into
    Member (TEAM_ID, USERNAME, MEMBER_ID)
    values
    (?, ?, ?)
  ```

  - Team 객체의 name 필드를 바로 꺼낼 수 있음!
- 💡다시 한번 복습!
  - JPA는 commit할 때 INSERT SQL문을 DB에 날린다고 했는데 INSERT 전에 Team의 값이 출력되는 이유는❓
    - `@GeneratedValue` 를 사용하게 되면 JPA에서 해당 테이블의 컬럼에 값을 자동으로 추가해준다고 했는데 이는 persist()에서 진행됨!
    - 따라서 INSERT 전에 `@GeneratedValue` 는 DB에 들어가기 때문에 값을 조회할 수 있다!
  - DB랑 싱크를 완전히 맞추고 싶다면 `em.flush()`, `em.clean()`을 통해 영속성을 완전히 끊게 되며, DB에 쿼리가 바로 날라감!
    ```
    Hibernate: 
    /* insert for
        hellojpa.Team */insert 
    into
        Team (name, TEAM_ID) 
    values
        (?, ?) 
    Hibernate:
    /* insert for
    hellojpa.Member */insert
    into
    Member (TEAM_ID, USERNAME, MEMBER_ID)
    values
    (?, ?, ?)
    Hibernate:
    select 
    m1_0.MEMBER_ID,
    t1_0.TEAM_ID,
    t1_0.name,
    m1_0.USERNAME
    from
    Member m1_0
    left join
    Team t1_0
    on t1_0.TEAM_ID=m1_0.TEAM_ID
    where
    m1_0.MEMBER_ID=?
    findTeam.getName() = TeamA
    ```
    - INSERT 이후 조회

</details>

🔑 ORM 매핑

<img src="https://github.com/iieunji023/jpa-with-spring-boot-basic/blob/main/images/단방향4.png" width="350">

🔑 **연관관계 수정**

- TeamA를  TeamB로 변경하고 싶을 때
- JpaMain.java

    ```
    Team newTeam = em.find(Team.class, 100L);
    findMember.setTeam(newTeam);
    ```

  - Team 테이블의 Id가 100인 팀으로 바꾸고 싶다면 위 코드처럼만 해주면 된다

<br>

